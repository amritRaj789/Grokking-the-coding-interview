// A huge number of coding interview problems involve dealing with 
//Permutations, Combinations of a given set of elements. This pattern describes an efficient BFS approach

// Problem 1
// Given a set with distinct elements, find all of its distinct subsets

// my way: dfs
const find_subsets = function(nums) {
	let result = [];
	function dfs(i, arr){
		if(i === nums.length){
			result.push([...arr]);
			return
		}
		dfs(i+1, [...arr, nums[i]]);
		dfs(i+1, [...arr]);
	}
	dfs(0, []);
	return result;
};

// bfs recursive
const find_subsets = function (nums){
	let result = [[]];
	function bfs(index){
		if(index === nums.length)
			return
		let length = result.length;
		for(let i = 0; i < length; i++){
			result.push([...result[i], nums[index]]);
		}
		bfs(index+1);
	}
	bfs(0);
	return result;
}

// bfs iterative
const find_subsets = function (nums){
	let result = [[]];
	for(let i = 0; i < nums.length; i++){
		let length = result.length;
		for(let j = 0; j < length; j++){
			result.push([...result[j], nums[i]]);
		}
	}
	return result;
}
// O(N*2^N) space and time


//Problem 2
// Subsets with duplicates


// bfs iterative
const find_subsets = function (nums){
	let result = [[], [nums[0]]];
	let prevLength = 1;
	let currLength;
	nums.sort((a,b) => a-b);
	for(let i = 1; i < nums.length; i++){
		currLength = result.length;
		if(nums[i] !== nums[i-1]){
			for(let j = 0; j < currLength; j++)
				result.push([...result[j], nums[i]]);
		}
		else{
			while(prevLength < currLength){
				result.push([...result[prevLength], nums[i]]);
				prevLength++;
			}
		}
		prevLength = currLength;
	}
	return result;
}
// O(n*2^n) space and time

// Porblem 3
// PERMUTATIONS
// Given a set of numbers, find all of its permutations and output them


// backtracking
let find_permutations = function (nums){
	let subsets = [];
	function backtrack(i, arr){
		if(i === nums.length){
			subsets.push([...arr]);
		}
		for(let j = 0; j < nums.length; j++){
			if(nums[j] !== false){
				let temp = nums[j];
				nums[j] = false;
				backtrack(i+1, [...arr, temp]);
				nums[j] = temp;
			}
		}
	}
	backtrack(0, []);
	return subsets;
}
// O(N*N!) time
// educative has it done it differently and I don't like their way


// Problem 4
// String permutations by changing case
//Given a string, output all permutations by changing case

// recursive brute force (DFS!!)
var find_letter_case_string_permutations = function(S) {
    let s = S.toLowerCase();
    let result = [];
    function recursive(index, string){
        if(index === s.length){
            result.push(string.slice(0));
            return
        }
        recursive(index+1, string.slice(0));
        if(s.charCodeAt(index) >= 97 && s.charCodeAt(index) <= 122)
            recursive(index+1, string.slice(0, index) + string[index].toUpperCase() + string.slice(index+1));
    }
    recursive(0, s);
    return result;
};

// iterative brute force (BFS!!)
let find_letter_case_string_permutations = function (string){
    let str = string.toLowerCase();
	let result = [str.slice(0)];
	for(let i = 0; i < str.length; i++){
		if(str.charCodeAt(i) < 97 || str.charCodeAt(i) > 122)
			continue
		let length = result.length;
		for(let j = 0; j < length; j++)
			result.push(result[j].slice(0, i) + result[j][i].toUpperCase() + result[j].slice(i+1))
	}
	return result;
}

// both of the above methods gave me the same efficiency in leetcode trials


// Problem 5
// Balanced Parentheses
//For a given number ‘N’, write a function to generate all combination of ‘N’ pairs of balanced parentheses.

// DFS backtracking
let generate_valid_parentheses = function (num){
	function recursive(openCount, closeCount, str){
		if(openCount === num && closeCount === num){
			result.push(str.slice(0))
			return
		}
		if(closeCount > openCount || openCount > num)
			return
		recursive(openCount+1, closeCount, str.slice(0)+"(")
		recursive(openCount, closeCount+1, str.slice(0)+")");
	}
	recursive(1, 0, "(");
	return result;
}



// Problem 6
// Unique Generalized Abbreviations

/*Given a word, write a function to generate all of its unique generalized abbreviations.
Generalized abbreviation of a word can be generated by replacing each substring of the 
word by the count of characters in the substring. Take the example of “ab” which 
has four substrings: “”, “a”, “b”, and “ab”. After replacing these substrings in the actual word by the count of characters we get all the generalized abbreviations: “ab”, “1b”, “a1”, and “2”.
*/

// DFS recursive
let generate_generalized_abbreviation = function (word){
	let result = [];
	function recursive (i, count, str){
		if(i === word.length){
			result.push(str.slice(0) + (count === 0 ? "" : count));
			return
		}
		recursive(i+1, 0, str.slice(0) + (count === 0 ? "" : count) + word[i]);
		recursive(i+1, count+1, str.slice(0));
	}
	recursive(0, 0, "");
	return result;
}



// Problem Challenge 1
// Evaluate Expression

// this is what I originally thought but since we cannot use eval I gotta do it differently
const diff_ways_to_evaluate_expression = function (input){
	let result = [];
	let max = (input.length-1)/2;
	function recursive(index, str, open, close){
		if(open > max || close > open)
			return
		if(index === input.length){
			result.push(eval(str.slice(0)));
			return
		}
		recursive(index+2, str.slice(0, index) + "(" + str.slice(index+1), open+1, close);
		recursive(index+2, str.slice(0, index) + ")" + str.slice(index+1), open, close+1);
	}
	recursive(0, "", 0, 0);
	return result;
}

// this is the final correct solution
const diff_ways_to_evaluate_expression = function(input) {
	let result = [];
	if(input.length === 1)
		result.push(Number(input[0]));
	else{
		for(let i = 0; i < input.length; i++){
			let char = input[i]
			if(char === "+" || char === "-" || char === "*"){
				let left = diff_ways_to_evaluate_expression(input.slice(0, i));
				let right = diff_ways_to_evaluate_expression(input.slice(i+1));
				for(let i = 0; i < left.length; i++){
					for(let j = 0; j < right.length; j++){
						if(char === "+")
							result.push(left[i] + right[j])
						else if(char === "-")
							result.push(left[i] - right[j])
						else
							result.push(left[i] * right[j]);
					}
				}

			}
		}
	}
	return result;
};



// Problem Challenge 3
// Count of structurally unique BSTs

// classic DP question
let count_trees = function (n){
	let dp = Array(n+1).fill(0);
	dp[0] = 1;
	dp[1] = 1;
	for(let i = 2; i <= n; i++){
		for(let j = 0; j < i; j++){
			dp[i] += dp[j] * dp[i-1-j];
		}
	}
	return dp[n];
}